/**
 * Otreeba Open Cannabis API
 * This is an open, canonical database of cannabis seed companies, strains, brands, products, retailers, and studies from [Otreeba](https://otreeba.com). It is written on the OpenAPI Specification AKA Swagger. You can find out more about the Open API Initiative at [https://www.openapis.org/](https://www.openapis.org), or more info on Swagger at [http://swagger.io/](http://swagger.io/).
 *
 * OpenAPI spec version: 1.0.0
 * Contact: api@otreeba.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.otreeba.com/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class Brand {
    /**
    * Name of the brand.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the brand.
    */
    'ocpc': string;
    /**
    * URL for brand on Otreeba.
    */
    'link': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for brand on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for logo for brand.
    */
    'image': string;
    /**
    * OCPCs of the flowers from this brand.
    */
    'flowers': Array<string>;
    /**
    * OCPCs of the extracts from this brand.
    */
    'extracts': Array<string>;
    /**
    * OCPCs of the edibles from this brand.
    */
    'edibles': Array<string>;
    /**
    * OCPCs of the products from this brand.
    */
    'products': Array<string>;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Condition {
    /**
    * Name of the condition.
    */
    'name': string;
    /**
    * Slug based on the condition name.
    */
    'slug': string;
    /**
    * Description of the condition.
    */
    'description': string;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Edible {
    /**
    * Name of the edible.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the edible.
    */
    'ocpc': string;
    /**
    * Name and Open Cannabis Product Code of the brand that created this edible.
    */
    'brand': any;
    /**
    * Type of edible.
    */
    'type': string;
    /**
    * Name and Open Cannabis Product Code of the strain for this edible.
    */
    'strain': any;
    /**
    * Description of the edible.
    */
    'description': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for the edible on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for the main photo of the edible.
    */
    'image': string;
    /**
    * URL for the PDF containing lab testing information for this edible.
    */
    'labTest': string;
    /**
    * THC measurement for this edible.
    */
    'thc': string;
    /**
    * CBD measurement for this edible.
    */
    'cbd': string;
    /**
    * Cannabis measurement for this edible.
    */
    'cannabis': string;
    /**
    * Hash oil measurement for this edible.
    */
    'hashOil': string;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Extract {
    /**
    * Name of the extract.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the extract.
    */
    'ocpc': string;
    /**
    * Name and Open Cannabis Product Code of the brand that created these extract.
    */
    'brand': any;
    /**
    * Type of extract.
    */
    'type': string;
    /**
    * Name and Open Cannabis Product Code of the strain for these extract.
    */
    'strain': any;
    /**
    * Description of the extract.
    */
    'description': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for the extract on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for the main photo of the extract.
    */
    'image': string;
    /**
    * URL for the PDF containing lab testing information for these extract.
    */
    'labTest': string;
    /**
    * THC measurement for these extract.
    */
    'thc': string;
    /**
    * CBD measurement for these extract.
    */
    'cbd': string;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Flower {
    /**
    * Name of the flowers.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the flowers.
    */
    'ocpc': string;
    /**
    * Name and Open Cannabis Product Code of the brand that created these flowers.
    */
    'brand': any;
    /**
    * Type of flowers.
    */
    'type': string;
    /**
    * Name and Open Cannabis Product Code of the strain for these flowers.
    */
    'strain': any;
    /**
    * Description of the flowers.
    */
    'description': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for the flowers on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for the main photo of the flowers.
    */
    'image': string;
    /**
    * URL for the PDF containing lab testing information for these flowers.
    */
    'labTest': string;
    /**
    * THC measurement for these flowers.
    */
    'thc': string;
    /**
    * CBD measurement for these flowers.
    */
    'cbd': string;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class InlineResponse200 {
    /**
    * Gets the current list of Seed Comapnies.
    */
    'meta': Meta;
}

export class InlineResponse2001 {
    'meta': InlineResponse2001Meta;
}

export class InlineResponse20010 {
    /**
    * Gets the current list of Products.
    */
    'meta': Meta;
}

export class InlineResponse20011 {
    /**
    * Gets the current list of Strains.
    */
    'meta': Meta;
}

export class InlineResponse20012 {
    /**
    * Gets the current list of Studies.
    */
    'meta': Meta;
}

export class InlineResponse20013 {
    /**
    * Gets the current list of Studies for a given Condition.
    */
    'meta': Meta;
}

/**
* Gets the Strains for a Seed Company listing from a given OCPC.
*/
export class InlineResponse2001Meta {
    /**
    * Gets the Strains for a Seed Company listing from a given OCPC.
    */
    'pagination': Pagination;
}

export class InlineResponse2002 {
    /**
    * Gets the current list of Edibles.
    */
    'meta': Meta;
}

export class InlineResponse2003 {
    /**
    * Gets the current list of Extracts.
    */
    'meta': Meta;
}

export class InlineResponse2004 {
    /**
    * Gets the current list of Flowers.
    */
    'meta': Meta;
}

export class InlineResponse2005 {
    /**
    * Gets the current list of Brands.
    */
    'meta': Meta;
}

export class InlineResponse2006 {
    /**
    * Gets the current list of Flowers for a Brand.
    */
    'meta': Meta;
}

export class InlineResponse2007 {
    /**
    * Gets the current list of Extracts for a Brand.
    */
    'meta': Meta;
}

export class InlineResponse2008 {
    /**
    * Gets the current list of Edibles for a Brand.
    */
    'meta': Meta;
}

export class InlineResponse2009 {
    /**
    * Gets the current list of Products for a Brand.
    */
    'meta': Meta;
}

export class Meta {
    'pagination': Pagination;
}

export class ModelError {
    'code': number;
    'message': string;
}

export class Pagination {
    /**
    * Total number of results available.
    */
    'total': number;
    /**
    * Number of results to return. Default 10. Max 50.
    */
    'count': number;
    /**
    * Number of results per page.
    */
    'perPage': number;
    /**
    * Page of results.
    */
    'currentPage': number;
    /**
    * Total number of pages of results.
    */
    'totalPages': number;
    /**
    * Links to the previous and/or next pages of results.
    */
    'links': any;
}

export class Product {
    /**
    * Name of the product.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the product.
    */
    'ocpc': string;
    /**
    * Name and Open Cannabis Product Code of the brand that created this product.
    */
    'brand': any;
    /**
    * Type of product.
    */
    'type': string;
    /**
    * Name and Open Cannabis Product Code of the strain for this product.
    */
    'strain': any;
    /**
    * Description of the product.
    */
    'description': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for the product on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for the main photo of the product.
    */
    'image': string;
    /**
    * URL for the PDF containing lab testing information for this product.
    */
    'labTest': string;
    /**
    * THC measurement for this product.
    */
    'thc': string;
    /**
    * CBD measurement for this product.
    */
    'cbd': string;
    /**
    * Cannabis measurement for this product.
    */
    'cannabis': string;
    /**
    * Hash oil measurement for this product.
    */
    'hashOil': string;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class SeedCompany {
    /**
    * Name of the seed company.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the seed company.
    */
    'ocpc': string;
    /**
    * Description of the seed company.
    */
    'description': string;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for seed company on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for logo for seed company.
    */
    'image': string;
    /**
    * Object of countries that this seed company has lineages from. {'Country Name' => 'ISO 3166-1 Two Letter Country Code'}
    */
    'lineage': any;
    /**
    * OCPCs of the strains from this seed company.
    */
    'strains': Array<string>;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Strain {
    /**
    * Name of the strain.
    */
    'name': string;
    /**
    * Open Cannabis Product Code for the strain.
    */
    'ocpc': string;
    /**
    * Name and Open Cannabis Product Code of the seed company that created the strain.
    */
    'seedCompany': any;
    /**
    * URL for QR that leads to page on Cannabis Reports.
    */
    'qr': string;
    /**
    * URL for strain on Cannabis Reports.
    */
    'url': string;
    /**
    * URL for the main photo of the strain.
    */
    'image': string;
    /**
    * Object of countries that this strain has lineages from. {'Country Name' => 'ISO 3166-1 Two Letter Country Code'}
    */
    'lineage': any;
    /**
    * Names of the parents of the strains and their associated Open Cannabis Product Codes.
    */
    'genetics': any;
    /**
    * Open Cannabis Product Codes of the children of this strain.
    */
    'children': Array<string>;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}

export class Study {
    /**
    * Name of the study.
    */
    'name': string;
    /**
    * Year of the study.
    */
    'year': number;
    /**
    * Digital Object Identifier for the study.
    */
    'doi': string;
    /**
    * PubMed ID for the study.
    */
    'pubMedId': string;
    /**
    * Slug based on the study name.
    */
    'slug': string;
    /**
    * Key findings for the study.
    */
    'keyFindings': string;
    'conditions': Array<Condition>;
    /**
    * Date and time record was created, UTC.
    */
    'createdAt': Date;
    /**
    * Date and time record was updated, UTC.
    */
    'updatedAt': Date;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum BrandsApiApiKeys {
    api_key,
}

export class BrandsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BrandsApiApiKeys, value: string) {
        this.authentications[BrandsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single brand.
     * @summary Find brand by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the brand to return.
     */
    public getBrandByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Brand;  }> {
        const localVarPath = this.basePath + '/brands/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getBrandByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Brand;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of edibles.
     * @summary Get a list of all current edibles for the given brand.
     * @param ocpc OCPC of the brand to list edibles for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getBrandEdibles (ocpc: string, page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/brands/{ocpc}/edibles'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getBrandEdibles.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of extracts.
     * @summary Get a list of all current extracts for the given brand.
     * @param ocpc OCPC of the brand to list extracts for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getBrandExtracts (ocpc: string, page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/brands/{ocpc}/extracts'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getBrandExtracts.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of flowers.
     * @summary Get a list of all current flowers for the given brand.
     * @param ocpc OCPC of the brand to list flowers for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getBrandFlowers (ocpc: string, page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/brands/{ocpc}/flowers'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getBrandFlowers.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of products.
     * @summary Get a list of all current products for the given brand.
     * @param ocpc OCPC of the brand to list products for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getBrandProducts (ocpc: string, page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/brands/{ocpc}/products'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getBrandProducts.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of brands.
     * @summary Get a list of all current brands.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getBrands (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }> {
        const localVarPath = this.basePath + '/brands';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdiblesApiApiKeys {
    api_key,
}

export class EdiblesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdiblesApiApiKeys, value: string) {
        this.authentications[EdiblesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single edible.
     * @summary Find edible by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the edible to return.
     */
    public getEdibleByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Edible;  }> {
        const localVarPath = this.basePath + '/edibles/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getEdibleByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Edible;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of edibles.
     * @summary Get a list of all current edibles.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getEdibles (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/edibles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExtractsApiApiKeys {
    api_key,
}

export class ExtractsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExtractsApiApiKeys, value: string) {
        this.authentications[ExtractsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single extract.
     * @summary Find extract by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the extract to return.
     */
    public getExtractByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Extract;  }> {
        const localVarPath = this.basePath + '/extracts/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getExtractByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Extract;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of extracts.
     * @summary Get a list of all current extracts.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getExtracts (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/extracts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FlowersApiApiKeys {
    api_key,
}

export class FlowersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FlowersApiApiKeys, value: string) {
        this.authentications[FlowersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single flower.
     * @summary Find flower by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the flower to return.
     */
    public getFlowerByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Flower;  }> {
        const localVarPath = this.basePath + '/flowers/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getFlowerByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Flower;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of flowers.
     * @summary Get a list of all current flowers.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getFlowers (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/flowers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductsApiApiKeys {
    api_key,
}

export class ProductsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductsApiApiKeys, value: string) {
        this.authentications[ProductsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single product.
     * @summary Find product by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the product to return.
     */
    public getProductByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Product;  }> {
        const localVarPath = this.basePath + '/products/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getProductByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Product;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of products.
     * @summary Get a list of all current products.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getProducts (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }> {
        const localVarPath = this.basePath + '/products';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SeedCompaniesApiApiKeys {
    api_key,
}

export class SeedCompaniesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SeedCompaniesApiApiKeys, value: string) {
        this.authentications[SeedCompaniesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a paginated list of seed companies.
     * @summary Get a list of all current seed companies.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getSeedCompanies (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/seed-companies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single seed company.
     * @summary Find seed company by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the seed company to return.
     */
    public getSeedCompanyByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: SeedCompany;  }> {
        const localVarPath = this.basePath + '/seed-companies/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getSeedCompanyByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SeedCompany;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of strains for a single seed company.
     * @summary Find strains for a seed company by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the seed company to return strains for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     */
    public getSeedCompanyStrainsByOcpc (ocpc: string, page?: number, count?: number) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/seed-companies/{ocpc}/strains'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getSeedCompanyStrainsByOcpc.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StrainsApiApiKeys {
    api_key,
}

export class StrainsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StrainsApiApiKeys, value: string) {
        this.authentications[StrainsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a single strain.
     * @summary Find strain by Open Cannabis Product Code (OCPC).
     * @param ocpc OCPC of the strain to return.
     */
    public getStrainByOcpc (ocpc: string) : Promise<{ response: http.ClientResponse; body: Strain;  }> {
        const localVarPath = this.basePath + '/strains/{ocpc}'
            .replace('{' + 'ocpc' + '}', String(ocpc));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ocpc' is not null or undefined
        if (ocpc === null || ocpc === undefined) {
            throw new Error('Required parameter ocpc was null or undefined when calling getStrainByOcpc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Strain;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of strains.
     * @summary Get a list of all current strains.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getStrains (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }> {
        const localVarPath = this.basePath + '/strains';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StudiesApiApiKeys {
    api_key,
}

export class StudiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'X-API-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StudiesApiApiKeys, value: string) {
        this.authentications[StudiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a paginated list of studies.
     * @summary Get a list of all current studies.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getStudies (page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }> {
        const localVarPath = this.basePath + '/studies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a paginated list of studies.
     * @summary Get a list of all current studies for a given condition.
     * @param conditionSlug Slug of the condition to return studies for.
     * @param page Page to be returned.
     * @param count The number of items to return. Default 10. Max 50.
     * @param sort How to sort the items.
     */
    public getStudiesByCondition (conditionSlug: string, page?: number, count?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }> {
        const localVarPath = this.basePath + '/studies/conditions/{conditionSlug}'
            .replace('{' + 'conditionSlug' + '}', String(conditionSlug));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'conditionSlug' is not null or undefined
        if (conditionSlug === null || conditionSlug === undefined) {
            throw new Error('Required parameter conditionSlug was null or undefined when calling getStudiesByCondition.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of all current conditions for studies.
     * @summary Get a list of all current conditions for studies.
     * @param sort How to sort the items.
     */
    public getStudiesConditions (sort?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/studies/conditions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single study.
     * @summary Find study by DOI, PubMed ID, or slug.
     * @param identifierType Type of identifier to for the study to return.
     * @param identifier Identifier for the study to return.
     */
    public getStudyByIdentifier (identifierType: string, identifier: string) : Promise<{ response: http.ClientResponse; body: Study;  }> {
        const localVarPath = this.basePath + '/studies/{identifierType}/{identifier}'
            .replace('{' + 'identifierType' + '}', String(identifierType))
            .replace('{' + 'identifier' + '}', String(identifier));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'identifierType' is not null or undefined
        if (identifierType === null || identifierType === undefined) {
            throw new Error('Required parameter identifierType was null or undefined when calling getStudyByIdentifier.');
        }

        // verify required parameter 'identifier' is not null or undefined
        if (identifier === null || identifier === undefined) {
            throw new Error('Required parameter identifier was null or undefined when calling getStudyByIdentifier.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Study;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
