/**
 * Otreeba Open Cannabis API
 * This is an open, canonical database of cannabis seed companies, strains, brands, products, retailers, and studies from [Otreeba](https://otreeba.com). It is written on the OpenAPI Specification AKA Swagger. You can find out more about the Open API Initiative at [https://www.openapis.org/](https://www.openapis.org), or more info on Swagger at [http://swagger.io/](http://swagger.io/).
 *
 * OpenAPI spec version: 1.0.0
 * Contact: api@otreeba.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.2.3.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "Pagination.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

Pagination::Pagination()
{
    m_Total = 0;
    m_TotalIsSet = false;
    m_Count = 0;
    m_CountIsSet = false;
    m_Per_page = 0;
    m_Per_pageIsSet = false;
    m_Current_page = 0;
    m_Current_pageIsSet = false;
    m_Total_pages = 0;
    m_Total_pagesIsSet = false;
    m_LinksIsSet = false;
}

Pagination::~Pagination()
{
}

void Pagination::validate()
{
    // TODO: implement validation
}

web::json::value Pagination::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_TotalIsSet)
    {
        val[U("total")] = ModelBase::toJson(m_Total);
    }
    if(m_CountIsSet)
    {
        val[U("count")] = ModelBase::toJson(m_Count);
    }
    if(m_Per_pageIsSet)
    {
        val[U("per_page")] = ModelBase::toJson(m_Per_page);
    }
    if(m_Current_pageIsSet)
    {
        val[U("current_page")] = ModelBase::toJson(m_Current_page);
    }
    if(m_Total_pagesIsSet)
    {
        val[U("total_pages")] = ModelBase::toJson(m_Total_pages);
    }
    if(m_LinksIsSet)
    {
        val[U("links")] = ModelBase::toJson(m_Links);
    }

    return val;
}

void Pagination::fromJson(web::json::value& val)
{
    if(val.has_field(U("total")))
    {
        setTotal(ModelBase::int32_tFromJson(val[U("total")]));
    }
    if(val.has_field(U("count")))
    {
        setCount(ModelBase::int32_tFromJson(val[U("count")]));
    }
    if(val.has_field(U("per_page")))
    {
        setPerPage(ModelBase::int32_tFromJson(val[U("per_page")]));
    }
    if(val.has_field(U("current_page")))
    {
        setCurrentPage(ModelBase::int32_tFromJson(val[U("current_page")]));
    }
    if(val.has_field(U("total_pages")))
    {
        setTotalPages(ModelBase::int32_tFromJson(val[U("total_pages")]));
    }
    if(val.has_field(U("links")))
    {
        if(!val[U("links")].is_null())
        {
            std::shared_ptr<Object> newItem(nullptr);
            newItem->fromJson(val[U("links")]);
            setLinks( newItem );
        }
    }
}

void Pagination::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(m_TotalIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("total"), m_Total));
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("count"), m_Count));
    }
    if(m_Per_pageIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("per_page"), m_Per_page));
    }
    if(m_Current_pageIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("current_page"), m_Current_page));
    }
    if(m_Total_pagesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("total_pages"), m_Total_pages));
    }
    if(m_LinksIsSet)
    {
        if (m_Links.get())
        {
            m_Links->toMultipart(multipart, U("links."));
        }
        
    }
}

void Pagination::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(multipart->hasContent(U("total")))
    {
        setTotal(ModelBase::int32_tFromHttpContent(multipart->getContent(U("total"))));
    }
    if(multipart->hasContent(U("count")))
    {
        setCount(ModelBase::int32_tFromHttpContent(multipart->getContent(U("count"))));
    }
    if(multipart->hasContent(U("per_page")))
    {
        setPerPage(ModelBase::int32_tFromHttpContent(multipart->getContent(U("per_page"))));
    }
    if(multipart->hasContent(U("current_page")))
    {
        setCurrentPage(ModelBase::int32_tFromHttpContent(multipart->getContent(U("current_page"))));
    }
    if(multipart->hasContent(U("total_pages")))
    {
        setTotalPages(ModelBase::int32_tFromHttpContent(multipart->getContent(U("total_pages"))));
    }
    if(multipart->hasContent(U("links")))
    {
        if(multipart->hasContent(U("links")))
        {
            std::shared_ptr<Object> newItem(nullptr);
            newItem->fromMultiPart(multipart, U("links."));
            setLinks( newItem );
        }
    }
}

int32_t Pagination::getTotal() const
{
    return m_Total;
}


void Pagination::setTotal(int32_t value)
{
    m_Total = value;
    m_TotalIsSet = true;
}
bool Pagination::totalIsSet() const
{
    return m_TotalIsSet;
}

void Pagination::unsetTotal()
{
    m_TotalIsSet = false;
}

int32_t Pagination::getCount() const
{
    return m_Count;
}


void Pagination::setCount(int32_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}
bool Pagination::countIsSet() const
{
    return m_CountIsSet;
}

void Pagination::unsetCount()
{
    m_CountIsSet = false;
}

int32_t Pagination::getPerPage() const
{
    return m_Per_page;
}


void Pagination::setPerPage(int32_t value)
{
    m_Per_page = value;
    m_Per_pageIsSet = true;
}
bool Pagination::perPageIsSet() const
{
    return m_Per_pageIsSet;
}

void Pagination::unsetPer_page()
{
    m_Per_pageIsSet = false;
}

int32_t Pagination::getCurrentPage() const
{
    return m_Current_page;
}


void Pagination::setCurrentPage(int32_t value)
{
    m_Current_page = value;
    m_Current_pageIsSet = true;
}
bool Pagination::currentPageIsSet() const
{
    return m_Current_pageIsSet;
}

void Pagination::unsetCurrent_page()
{
    m_Current_pageIsSet = false;
}

int32_t Pagination::getTotalPages() const
{
    return m_Total_pages;
}


void Pagination::setTotalPages(int32_t value)
{
    m_Total_pages = value;
    m_Total_pagesIsSet = true;
}
bool Pagination::totalPagesIsSet() const
{
    return m_Total_pagesIsSet;
}

void Pagination::unsetTotal_pages()
{
    m_Total_pagesIsSet = false;
}

std::shared_ptr<Object> Pagination::getLinks() const
{
    return m_Links;
}


void Pagination::setLinks(std::shared_ptr<Object> value)
{
    m_Links = value;
    m_LinksIsSet = true;
}
bool Pagination::linksIsSet() const
{
    return m_LinksIsSet;
}

void Pagination::unsetLinks()
{
    m_LinksIsSet = false;
}

}
}
}
}

